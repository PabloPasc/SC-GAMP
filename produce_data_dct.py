#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Feb 21 17:36:45 2023

@author: pp423
"""
import numpy as np
from scipy.fftpack import dct, idct

def sub_dct_iid(m, n, seed=0, order0=None, order1=None):
    """
    
    Returns functions to compute the sub-sampled Discrete Cosine Transform,
    i.e., matrix-vector multiply with subsampled rows from the DCT matrix.
    This is a direct modification of Adam Greig's pyfht source code which can
    be found at https://github.com/adamgreig/pyfht/blob/master/pyfht.py
    
    [Inputs]
    m: number of rows
    n: number of columns
    m < n
    Most efficient (but not required) for max(m+1,n+1) to be a power of 2.
    seed:   determines choice of random matrix
    order0: optional m-long array of row indices in [1, max(m+1,n+1)] to
            implement subsampling of rows; generated by seed if not specified.
    order1: optional n-long array of row indices in [1, max(m+1,n+1)] to
            implement subsampling of columns; generated by seed if not specified.
    [Outputs]
    Ax(x):    computes A.x (of length m), with x having length n
    Ay(y):    computes A*.y (of length n), with y having length m
    
    [Notes]
    There is a scaling of 1/sqrt(m) in the outputs of Ax() and Ay().
    """
    
    assert type(m)==int and m>0
    assert type(n)==int and n>0
    w = 2**int(np.ceil(np.log2(max(m+1,n+1))))

    if order0 is not None and order1 is not None:
        assert order0.shape == (m,)
        assert order1.shape == (n,)
    else:
        rng = np.random.RandomState(seed)
        idxs0 = np.arange(1, w, dtype=np.uint32)
        idxs1 = np.arange(1, w, dtype=np.uint32)
        rng.shuffle(idxs0)
        rng.shuffle(idxs1)
        order0 = idxs0[:m]
        order1 = idxs1[:n]

    def Ax(x):
        assert x.size == n, "x must be n long"
        x_ext = np.zeros(w)
        #print("x",x, "Size ", x.size)
        x_ext[order1] = x.reshape(n)
        #print("Shuffled:", x_ext, "Size ", x.size)
        #print(order1)
        y = np.sqrt(w)*dct(x_ext, norm='ortho')
        #print(y.size)
        return y[order0]/np.sqrt(m)

    def Ay(y):
        assert y.size == m, "input must be m long"
        y_ext = np.zeros(w)
        y_ext[order0] = y
        x_ext = np.sqrt(w)*idct(y_ext, norm='ortho')
        return x_ext[order1]/np.sqrt(m)

    return Ax, Ay

def sub_fft_iid(m, n, seed=0, order0=None, order1=None):
    """
    Returns functions to compute the sub-sampled fast Fourier transform,
    i.e., matrix-vector multiply with subsampled rows from the DFT matrix.

    This is a direct modification of Adam Greig's pyfht source code which can
    be found at https://github.com/adamgreig/pyfht/blob/master/pyfht.py

    [Parameters]
    m: number of rows
    n: number of columns
    m < n
    Most efficient (but not required) for max(m+1,n+1) to be a power of 2.
    seed:   determines choice of random matrix
    order0: optional m-long array of row indices in [1, max(m+1,n+1)] to
            implement subsampling of rows; generated by seed if not specified.
    order1: optional n-long array of row indices in [1, max(m+1,n+1)] to
            implement subsampling of columns; generated by seed if not specified.

    [Returns]
    Ax(x):    computes A.x (of length m), with x having length n
    Ay(y):    computes A*.y (of length n), with y having length m
    """
    assert type(m)==int and m>0
    assert type(n)==int and n>0
    w = 2**int(np.ceil(np.log2(max(m+2,n+2))))

    if order0 is not None and order1 is not None:
        assert order0.shape == (m,)
        assert order1.shape == (n,)
    else:
        rng = np.random.RandomState(seed)
        idxs0 = np.delete(np.arange(w, dtype=np.uint32), [0, w//2])
        idxs1 = np.delete(np.arange(w, dtype=np.uint32), [0, w//2])
        rng.shuffle(idxs0)
        rng.shuffle(idxs1)
        order0 = idxs0[:m]
        order1 = idxs1[:n]

    def Ax(x):
        assert x.size == n, "x must be n long"
        x_ext = np.zeros(w, dtype=complex)
        x_ext[order1] = x.reshape(n)
        y = np.fft.fft(x_ext)
        return y[order0]/np.sqrt(m)

    def Ay(y):
        assert y.size == m, "input must be m long"
        y_ext = np.zeros(w, dtype=complex)
        y_ext[order0] = y
        x_ext = np.fft.fft(y_ext.conj()).conj()
        return x_ext[order1]/np.sqrt(m)

    return Ax, Ay


def sub_dct_iid_mat(m, n, k, seed=0, order0=None, order1=None):
    """
    
    Returns functions to compute the sub-sampled Discrete Cosine Transform,
    i.e., matrix-matrix multiply with subsampled rows from the DCT matrix.
    This does not seem to provide significant improvement in runtime (less 
    significant as m,n become larger) wrt using a for loop over 
    each of the columns of the matrix (for k small).
    
    [Inputs]
    m: number of rows of design matrix
    n: number of columns of design matrix
    k: number of columns of signal X
    Most efficient (but not required) for max(m+1,n+1) to be a power of 2.
    seed:   determines choice of random matrix
    order0: optional m-long array of row indices in [1, max(m+1,n+1)] to
            implement subsampling of rows; generated by seed if not specified.
    order1: optional n-long array of row indices in [1, max(m+1,n+1)] to
            implement subsampling of columns; generated by seed if not specified.
    [Outputs]
    AX(X):    computes A.X (of dim. m*k), with x having dim. n*k
    AY(Y):    computes A*.Y (of dim. n*k), with y having dim. m*k
    
    [Notes]
    There is a scaling of 1/sqrt(m) in the outputs of Ax() and Ay().
    """
    
    assert type(m)==int and m>0
    assert type(n)==int and n>0
    w = 2**int(np.ceil(np.log2(max(m+1,n+1))))

    if order0 is not None and order1 is not None:
        assert order0.shape == (m,)
        assert order1.shape == (n,)
    else:
        rng = np.random.RandomState(seed)
        idxs0 = np.arange(1, w, dtype=np.uint32)
        idxs1 = np.arange(1, w, dtype=np.uint32)
        rng.shuffle(idxs0)
        rng.shuffle(idxs1)
        order0 = idxs0[:m]
        order1 = idxs1[:n]

    def AX(X):
        assert X.shape[0] == n, "X must have n rows"
        X_ext = np.zeros((w, k))
        #Is this reshape in next line necessary?
        X_ext[order1] = X#.reshape(n,k)
        Y = np.sqrt(w)*dct(X_ext, axis=0, norm='ortho')#DCT on each column of X
        return Y[order0]/np.sqrt(m)

    def AY(Y):
        assert Y.shape[0] == m, "Y must have m rows"
        Y_ext = np.zeros((w, k))
        Y_ext[order0] = Y
        X_ext = np.sqrt(w)*idct(Y_ext, axis=0, norm='ortho')#IDCT on each col. of Y
        return X_ext[order1]/np.sqrt(m)

    return AX, AY

def sub_dct(m, n, seed=0, order0=None, order1=None):
    """
    Returns functions to compute the sub-sampled fast Fourier transform,
    i.e., matrix-vector multiply with subsampled rows from the DFT matrix.
    This is a direct modification of Adam Greig's pyfht source code which can
    be found at https://github.com/adamgreig/pyfht/blob/master/pyfht.py
    [Parameters]
    m: number of rows
    n: number of columns
    m < n
    Most efficient (but not required) for max(m+1,n+1) to be a power of 2.
    seed:   determines choice of random matrix
    order0: optional m-long array of row indices in [1, max(m+1,n+1)] to
            implement subsampling of rows; generated by seed if not specified.
    order1: optional n-long array of row indices in [1, max(m+1,n+1)] to
            implement subsampling of columns; generated by seed if not specified.
    [Returns]
    Ax(x):    computes A.x (of length m), with x having length n
    Ay(y):    computes A*.y (of length n), with y having length m
    
    [Notes]
    No scaling of 1/sqrt(m) in outputs here
    """
    assert type(m)==int and m>0
    assert type(n)==int and n>0
    w = 2**int(np.ceil(np.log2(max(m+1,n+1))))

    if order0 is not None and order1 is not None:
        assert order0.shape == (m,)
        assert order1.shape == (n,)
    else:
        rng = np.random.RandomState(seed)
        idxs0 = np.arange(1, w, dtype=np.uint32)
        idxs1 = np.arange(1, w, dtype=np.uint32)
        rng.shuffle(idxs0)
        rng.shuffle(idxs1)
        order0 = idxs0[:m]
        order1 = idxs1[:n]

    def Ax(x):
        assert x.size == n, "x must be n long"
        x_ext = np.zeros(w)
        x_ext[order1] = x.reshape(n)
        y = np.sqrt(w)*dct(x_ext, norm='ortho')
        return y[order0]

    def Ay(y):
        assert y.size == m, "input must be m long"
        y_ext = np.zeros(w)
        y_ext[order0] = y
        x_ext = np.sqrt(w)*idct(y_ext, norm='ortho')
        return x_ext[order1]

    return Ax, Ay

def sc_dct(W, N, delta_hat, rand_seed):
    """
    Construct two functions to compute matrix-vector multiplications with a
    Hadamard design matrix `A` using the Discrete Cosine Transform (DCT),
    or with a Fourier design matrix using the fast Fourier Transform (FFT).
    W: an np.ndarray which determines design matrix variance structure, 
    base matrix of size R-by-C
    M: number of  rows   per block of the design matrix
    N: number of columns per block of the design matrix
    rand_seed: determines choice of random matrix
    Splits the overall matrix-vector multiplication into smaller blocks of 
    size `M` by `N` each. Uses `sub_dct` to compute the DCT of each block.
    Scale each block by a factor of sqrt(W[r,c]/M).
    Most efficient (but not required) when max(M+1,N+1) is a power of two.
    Returns
        Ab(x): computes `A` times `x` (`x` has length n)
        Az(y): computes `A` transpose times `y` (`y` has length m)
    """
    R, C = W.shape
    M = int(delta_hat*N)
    m, n = M*R, N*C  
    
    assert type(W)==np.ndarray
    assert type(m)==int and type(n)==int
    assert m>0 and n>0

    def generate_ordering(W, M, N, rand_seed):
        '''
        Generate random ordering for SPARC transforms
        '''

        W_shape = W.shape
        order0  = np.zeros(W_shape + (M,), dtype=np.uint32) # Row order
        order1  = np.zeros(W_shape + (N,), dtype=np.uint32) # Column order

        w = 2**int(np.ceil(np.log2(max(M+1, N+1)))) # Transform size
        idxs0 = np.arange(1, w, dtype=np.uint32)      # Avoid 1st row
        idxs1 = np.arange(1, w, dtype=np.uint32)      # Avoid 1st column


        rng = np.random.RandomState(rand_seed)
        if W.ndim == 0:
            rng.shuffle(idxs0)
            rng.shuffle(idxs1)
            order0 = idxs0[:M]
            order1 = idxs1[:N]
        elif W.ndim == 1:
            for b in range(W_shape[0]):
                rng.shuffle(idxs0)
                rng.shuffle(idxs1)
                order0[b] = idxs0[:M]
                order1[b] = idxs1[:N]
        elif W.ndim == 2:
            for r in range(W_shape[0]):
                for c in range(W_shape[1]):
                    if W[r,c] != 0:
                        rng.shuffle(idxs0)
                        rng.shuffle(idxs1)
                        order0[r,c] = idxs0[:M]
                        order1[r,c] = idxs1[:N]
        else:
            raise Exception("Something is wrong with the ordering")

        return order0, order1

    

    if W.ndim == 2:
        R, C = W.shape
        # Removed becomes sometimes it can be difficult to get dimensions matched
        assert n % C == 0
        assert m % R == 0
        N     = n // C
        M     = m // R
        order0, order1 = generate_ordering(W, M, N, rand_seed)

        ax = np.empty((R,C), dtype=np.object)
        ay = np.empty((R,C), dtype=np.object)
        for r in range(R):
            for c in range(C):
                if W[r,c] != 0:
                    ax[r,c], ay[r,c] = sub_dct(M, N, order0=order0[r,c],
                                                           order1=order1[r,c])

        def Ab(x):
            assert x.size == C*N
            out = np.zeros(R*M)
            for r in range(R):
                for c in range(C):
                    if W[r,c] != 0:
                        out[r*M:(r+1)*M] += (np.sqrt(W[r,c]/M)*
                                               ax[r,c](x[c*N:(c+1)*N]))
            return out

        def Az(y):
            assert y.size == R*M
            out = np.zeros(C*N)
            for r in range(R):
                for c in range(C):
                   if W[r,c] != 0:
                        out[c*N:(c+1)*N] += (np.sqrt(W[r,c]/M)*
                                               ay[r,c](y[r*M:(r+1)*M]))
            return out

    else:
        raise Exception('Something wrong with base matrix input W')

    return Ab, Az


"""L = 8191
k = 5
n=4095
Y_0 = np.zeros((n,k))

for i in range(k):
    y_0 = produce_data.create_x_0(1, n, "Discrete")
    Y_0[:,i] = y_0
AX, AY = sub_dct_iid_mat(n, L, k, seed=300)
start = time.time()
X = AY(Y_0)
end = time.time()
print(end-start)
x = np.zeros((L,k))

Ax, Ay = sub_dct_iid(n, L, seed=300)
start = time.time()
for i in range(k):
    x[:,i]= Ay(Y_0[:,i])
end = time.time()
print(end-start)"""
